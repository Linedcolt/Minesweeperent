<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Infinite Minesweeper</title>

<!-- App name for iOS / PWA -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="Infinite Minesweeper">
<meta name="application-name" content="Infinite Minesweeper">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#eaf8ef">

<!-- App icons (place files in /icons/ as described below) -->
<link rel="apple-touch-icon" sizes="180x180" href="icons/icon-180.png">
<link rel="apple-touch-icon" sizes="167x167" href="icons/icon-167.png">
<link rel="apple-touch-icon" sizes="152x152" href="icons/icon-152.png">
<link rel="apple-touch-icon" sizes="120x120" href="icons/icon-120.png">
<link rel="manifest" href="manifest.json">

<!-- Font -->
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700;800&display=swap" rel="stylesheet">

<style>
  html,body{height:100%;margin:0;overflow:hidden; overscroll-behavior: none; -webkit-overflow-scrolling: auto;}
  *{box-sizing:border-box; -webkit-tap-highlight-color: transparent; -webkit-user-select: none; user-select: none; -webkit-touch-callout: none;}
  :root{
    --bg: #eaf8ef;
    --panel: rgba(255,255,255,0.88);
    --accent: #2fa66a;
    --accent-2: #26a06a;
    --muted: #53606a;
    --glass-shadow: 0 12px 40px rgba(12,20,12,0.12);
    --radius: 14px;
  }
  body { font-family: 'Poppins', system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }

  #game{position:fixed; left:0; top:0; right:0; bottom:0; background:var(--bg); touch-action: none; -webkit-user-drag: none;}
  canvas{display:block; width:100%; height:100%;}

  .pauseBtn{ position:fixed; left:12px; top:12px; z-index:1500; width:46px; height:46px; border-radius:12px; display:flex; align-items:center; justify-content:center; background:var(--panel); box-shadow:var(--glass-shadow); border:1px solid rgba(0,0,0,0.05); font-size:20px; cursor:pointer;}
  .ui { position:fixed; right:12px; top:12px; z-index:1500; display:flex; flex-direction:column; gap:10px; pointer-events:auto; }
  .tool{ width:60px; height:60px; border-radius:14px; display:flex;align-items:center;justify-content:center; background:linear-gradient(180deg,#ffffff,#f7fff5); box-shadow:var(--glass-shadow); cursor:pointer; border:1px solid rgba(0,0,0,0.05); font-size:22px; }
  .tool.active{ outline:3px solid rgba(47,166,106,0.18); transform:translateY(-3px); }

  .overlay { position:fixed; inset:0; z-index:2000; display:flex; align-items:center; justify-content:center; background: rgba(8,12,10,0.18); backdrop-filter: blur(8px) saturate(1.05); }
  .menu { width: min(980px, 96vw); max-height:86vh; overflow:auto; background: linear-gradient(180deg, rgba(255,255,255,0.96), rgba(250,250,250,0.96)); border-radius:18px; padding:22px; box-shadow:0 30px 80px rgba(2,10,6,0.2); display:flex; gap:18px; align-items:flex-start; position:relative; }

  .menuLeft { width:44%; min-width:280px; padding:12px 6px 12px 6px; }
  .bigTitle{ font-weight:800; line-height:0.9; color:#0d2a18; font-size:48px; letter-spacing:-1px; }
  .bigTitle .line1{ display:block; color:var(--accent); }
  .bigTitle .line2{ display:block; color:#000; animation: colorToAccent 0.6s ease forwards 1s, accentPulse 2.7s ease-in-out infinite 1.7s; opacity:0.98; margin-top:6px; }

  .titleNote{ margin-top:14px; color:var(--muted); font-weight:600; font-size:14px; }

  .menuRight{ flex:1; padding:6px 6px; min-width:320px; }
  .actions { display:flex; flex-direction:column; gap:12px; align-items:stretch; } /* make buttons full width */
  .primaryBtn{
    appearance:none; border:none; cursor:pointer;
    padding:14px 18px; border-radius:12px; font-weight:800; font-size:16px;
    color:white; background:linear-gradient(180deg,var(--accent),var(--accent-2)); box-shadow: 0 10px 30px rgba(46,160,100,0.16);
    width:100%; text-align:center;
  }
  .secondaryBtn{
    padding:12px 14px; border-radius:10px; border:1px solid rgba(0,0,0,0.06);
    background:rgba(255,255,255,0.9); cursor:pointer; font-weight:700; color:var(--muted);
    width:100%; text-align:center;
  }
  .smallNote{ color:var(--muted); font-size:13px; margin-top:8px; line-height:1.3; }

  .worldList{ margin-top:10px; display:flex; flex-direction:column; gap:8px; }
  .worldCard{ display:flex; justify-content:space-between; align-items:center; gap:8px; padding:10px; border-radius:10px; background:linear-gradient(180deg,rgba(255,255,255,0.95), rgba(250,250,250,0.95)); border:1px solid rgba(0,0,0,0.04); }
  .worldLeft{ display:flex; align-items:center; gap:12px; }
  .worldTitle{ font-weight:800; color:#0b2b20; }
  .worldSeed{ font-size:12px; color:var(--muted); }
  .worldActions{ display:flex; gap:8px; }

  .row{ display:flex; gap:10px; align-items:center; }
  input[type="text"]{ padding:10px; border-radius:10px; border:1px solid rgba(0,0,0,0.06); width:100%; font-size:14px; }
  label{ display:block; font-size:13px; color:var(--muted); margin-bottom:6px; }

  .comingSoon{ font-weight:700; color:var(--muted); padding:18px; border-radius:12px; background:rgba(240,240,240,0.6); text-align:center; }
  .howtoBox{ color:var(--muted); font-size:14px; line-height:1.45; }

  .disabled { opacity:0.4; pointer-events:none; }
  @media (max-width:700px){ .menu{ flex-direction:column; width:96vw; padding:14px; } .menuLeft{ width:100%; } .menuRight{ width:100%; } .bigTitle{ font-size:36px; text-align:left; } }

  @keyframes colorToAccent { from { color: #000; transform: translateY(0px); } to   { color: var(--accent); transform: translateY(-2px); } }
  @keyframes accentPulse { 0% { filter: brightness(1); transform: translateY(0px); } 50% { filter: brightness(1.06); transform: translateY(-2px); } 100% { filter: brightness(1); transform: translateY(0px); } }
  button:focus, input:focus { outline: 3px solid rgba(39,174,96,0.14); outline-offset:2px; }

  /* playing badge */
  .playingBadge { font-size:12px; color:#0b5; background:rgba(46,166,106,0.08); border:1px solid rgba(46,166,106,0.12); padding:6px 8px; border-radius:999px; font-weight:700; }

  /* in-page console */
  #devConsole {
    position:fixed; right:12px; bottom:12px; width:420px; max-width:92vw; max-height:56vh; z-index:9999;
    background: #0c1112; color:#e6f7ef; border-radius:12px; box-shadow: 0 14px 60px rgba(0,0,0,0.5); padding:12px; font-family:monospace; display:none; flex-direction:column;
  }
  #devConsole .title { font-weight:800; color:#9ff3c9; margin-bottom:6px; }
  #devConsole pre { background:transparent; color:#bfead0; font-size:12px; margin:6px 0; overflow:auto; max-height:36vh; white-space:pre-wrap; word-break:break-word; }
  #devConsole .row { justify-content:space-between; }
  #devConsole button { padding:8px 10px; border-radius:8px; border:0; cursor:pointer; font-weight:700; }
  #devConsole .btnDanger { background:#d9534f; color:white; }
  #devConsole .btnPrimary { background:linear-gradient(180deg,#2fa66a,#26a06a); color:white; }
  #devConsole .small { font-size:12px; color:#98e6c1; }
</style>
</head>
<body>

<div id="game"><canvas id="c"></canvas></div>

<div class="pauseBtn" id="pauseBtn" title="Menu">‚è∏</div>

<div class="ui" id="toolsUI">
  <div id="shovelBtn" class="tool active" title="Shovel">üî®</div>
  <div id="flagBtn" class="tool" title="Flag">üö©</div>
  <div id="reviveBtn" class="tool" title="Revive">‚≠ê</div>
</div>

<!-- Overlay menu (shown on load and on pause) -->
<div id="overlay" class="overlay" style="display:none" aria-hidden="true">
  <div class="menu" role="dialog" aria-modal="true" id="menu">

    <div class="menuLeft">
      <div class="bigTitle" aria-hidden="true">
        <span class="line1">Infinite</span>
        <span class="line2">Minesweeper</span>
      </div>
      <div class="titleNote">Pick or create a world to start. Your progress is saved automatically.</div>
      <div style="margin-top:18px" id="selectedWorldInfo" class="smallNote">No world selected</div>
    </div>

    <div class="menuRight" id="menuRight">
      <div id="mainActions" class="actions">
        <button id="btnNew" class="primaryBtn">New Game</button>
        <button id="btnLoad" class="secondaryBtn">Load Game</button>
        <button id="btnSettings" class="secondaryBtn">Settings</button>
        <button id="btnHow" class="secondaryBtn">How to play</button>

        <!-- Resume / Save row (Save shown only when opened from pause button) -->
        <div style="display:flex; gap:10px; margin-top:8px;">
          <div style="flex:1;">
            <button id="btnResume" class="secondaryBtn" title="Resume" style="display:none">Resume</button>
          </div>
          <div style="flex:1;">
            <button id="btnSave" class="secondaryBtn" title="Save" style="display:none">Save</button>
          </div>
        </div>

        <div class="smallNote" style="margin-top:6px;">Create or load a world to play.</div>
      </div>

      <div id="panelNew" style="display:none">
        <div style="font-weight:800; font-size:18px; margin-bottom:6px">Create new world</div>
        <div class="smallNote">Give your world a name and optionally enter a seed. Same seed = same world.</div>
        <div style="margin-top:10px">
          <label for="newName">World name</label>
          <input id="newName" type="text" placeholder="My World">
        </div>
        <div style="margin-top:8px">
          <label for="newSeed">Seed (optional)</label>
          <input id="newSeed" type="text" placeholder="leave blank for a random seed">
        </div>
        <div style="margin-top:12px; display:flex; gap:8px;">
          <button id="createBtn" class="primaryBtn">Create World</button>
          <button id="cancelNew" class="secondaryBtn">Back</button>
        </div>
      </div>

      <div id="panelLoad" style="display:none">
        <div style="font-weight:800; font-size:18px; margin-bottom:6px">Load a world</div>
        <div class="smallNote">Pick a saved world to continue. You must select one to start playing.</div>
        <div class="worldList" id="worldList"></div>
        <div style="margin-top:12px; display:flex; gap:8px;">
          <button id="cancelLoad" class="secondaryBtn">Back</button>
        </div>
      </div>

      <div id="panelSettings" style="display:none">
        <div style="font-weight:800; font-size:18px; margin-bottom:6px">Settings</div>
        <div class="comingSoon">Coming soon ‚Äî display and control options will be added here.</div>
        <div style="margin-top:12px; display:flex; gap:8px;">
          <button id="cancelSettings" class="secondaryBtn">Back</button>
        </div>
      </div>

      <div id="panelHow" style="display:none">
        <div style="font-weight:800; font-size:18px; margin-bottom:6px">How to play</div>
        <div class="howtoBox">
          <p><strong>Tap</strong> tiles in <em>Shovel</em> mode to reveal. Switch to <em>Flag</em> mode to mark suspected mines with üö©.</p>
          <p><strong>First click is always safe.</strong> If your first click would be a mine it will be cleared.</p>
          <p>If you reveal a bomb, the whole 9√ó9 chunk will be disabled and the exploded tile will show a <strong>üí£</strong>. To revive it: solve its surrounding chunks (the red outline shows which area needs solving), or use a revive item (coming later).</p>
          <p>Progress is saved locally per world. Seeds are deterministic ‚Äî enter the same seed to regenerate the same world layout (biomes and mines).</p>
          <p>Pinch to zoom, drag to pan. When zoomed out the map simplifies to speed up rendering.</p>
        </div>
        <div style="margin-top:12px; display:flex; gap:8px;">
          <button id="cancelHow" class="secondaryBtn">Back</button>
        </div>
      </div>

    </div>
  </div>
</div>

<!-- In-page developer console (hidden until 'console' key sequence typed) -->
<div id="devConsole" role="dialog" aria-hidden="true">
  <div class="title">Dev Console ‚Äî Save diagnostics</div>
  <div class="row">
    <div class="small">Targeted checks for save issues</div>
    <div style="display:flex; gap:6px;">
      <button id="btnConsoleClose" class="btnDanger">Close</button>
      <button id="btnConsoleSaveTest" class="btnPrimary">Run Save Test</button>
    </div>
  </div>
  <pre id="consoleOutput">Press "Run Save Test" or type the sequence c,o,n,s,o,l,e to open this console.</pre>
  <div style="display:flex;gap:8px;margin-top:8px;">
    <button id="btnConsoleListKeys" class="secondaryBtn">List save keys</button>
    <button id="btnConsoleDownload" class="secondaryBtn">Download current save</button>
    <button id="btnConsoleCopy" class="secondaryBtn">Copy log</button>
  </div>
</div>

<script>
/* Focused edits:
   - Add IndexedDB fallback when localStorage quota is exceeded.
   - Update diagnostics so you can download from IDB if localStorage failed.
   - Only minimal changes ‚Äî rest of code unchanged.
*/

/* ===== CONFIG ===== */
const CHUNK_TILES = 9;
const DEFAULT_TILE = 36;
const MINE_PROB = 0.14;
const SAVE_PREFIX = 'ims_save_v4_';
const WORLDS_KEY = 'ims_worlds_v4';
let NOISE_SCALE = 0.16;

/* ===== Canvas + state ===== */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha: false });
let DPR = Math.max(1, window.devicePixelRatio || 1);
function resize(){ DPR = Math.max(1, window.devicePixelRatio || 1); canvas.width = Math.floor(canvas.clientWidth * DPR); canvas.height = Math.floor(canvas.clientHeight * DPR); }
window.addEventListener('resize', resize);
resize();

let cam = { x:0, y:0, scale:1.0 };
const chunks = new Map();
let firstClickDone = false;

/* world management */
let worlds = [];
let currentWorldId = null;
let currentSeedString = '';
let currentSeedNumber = 0;
function loadWorldMeta(){ try{ const raw = localStorage.getItem(WORLDS_KEY); worlds = raw ? JSON.parse(raw) : []; }catch(e){ worlds=[]; } }
function saveWorldMeta(){ localStorage.setItem(WORLDS_KEY, JSON.stringify(worlds)); }
loadWorldMeta();

/* Save diagnostics */
let lastSaveError = null;         // last thrown error (string)
let lastSavedAt = 0;             // timestamp
let lastSaveSize = 0;            // bytes (approx)
let lastSaveKey = null;          // key used (localStorage key or 'idb:ID')
let lastSaveMethod = null;       // 'localStorage' or 'indexedDB'

/* ===== IndexedDB helper (simple wrapper) ===== */
function openIdb() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open('ims_saves', 1);
    req.onupgradeneeded = (ev) => {
      const db = ev.target.result;
      if (!db.objectStoreNames.contains('saves')) db.createObjectStore('saves', { keyPath: 'id' });
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error || new Error('IDB open failed'));
  });
}
async function idbPut(id, payloadString) {
  try {
    const db = await openIdb();
    return new Promise((resolve, reject) => {
      const tx = db.transaction('saves', 'readwrite');
      const store = tx.objectStore('saves');
      const rec = { id: id, payload: payloadString, t: Date.now() };
      const r = store.put(rec);
      r.onsuccess = () => { resolve(true); db.close(); };
      r.onerror = () => { reject(r.error || new Error('idb put failed')); db.close(); };
    });
  } catch (e) { throw e; }
}
async function idbGet(id) {
  try {
    const db = await openIdb();
    return new Promise((resolve, reject) => {
      const tx = db.transaction('saves', 'readonly');
      const store = tx.objectStore('saves');
      const r = store.get(id);
      r.onsuccess = () => { resolve(r.result ? r.result.payload : null); db.close(); };
      r.onerror = () => { reject(r.error || new Error('idb get failed')); db.close(); };
    });
  } catch (e) { throw e; }
}
async function idbListKeysContaining(sub) {
  try {
    const db = await openIdb();
    return new Promise((resolve, reject) => {
      const tx = db.transaction('saves', 'readonly');
      const store = tx.objectStore('saves');
      const keys = [];
      const req = store.openCursor();
      req.onsuccess = (ev) => {
        const cursor = ev.target.result;
        if (cursor) {
          if (!sub || cursor.key.indexOf(sub) !== -1) keys.push(cursor.key);
          cursor.continue();
        } else { db.close(); resolve(keys); }
      };
      req.onerror = () => { db.close(); reject(req.error || new Error('idb cursor failed')); };
    });
  } catch (e) { throw e; }
}

/* RNG & game code (kept same except for save hooks) */
function hashStringToNumber(s){
  let h = 2166136261 >>> 0;
  for (let i=0;i<s.length;i++){ h ^= s.charCodeAt(i); h = Math.imul(h,16777619)>>>0; }
  h += h<<13; h ^= h>>>7; h += h<<3; h ^= h>>>17; h += h<<5;
  return h >>> 0;
}
function seedFromCoords(cx,cy,salt=0){ let s=(cx*0x6a09e667 + cy*0xbb67ae85 + (currentSeedNumber ^ salt))|0; if(s===0) s=1; return s>>>0; }
function rnd(u){ u ^= u << 13; u ^= u >>> 17; u ^= u << 5; return (u>>>0); }
function makeRNG(seed){ let x = seed>>>0; return ()=>{ x = rnd(x); return (x>>>0)/4294967296; }; }
function hash01(ix,iy,salt=0){
  let n = (ix*374761393 + iy*668265263 + (salt|0)) | 0;
  n = (n ^ (n >>> 13)) * 1274126177;
  return ((n ^ (n >>> 16)) >>> 0) / 4294967296;
}
function lerp(a,b,t){ return a + (b-a)*t; }
function smoothNoise(x,y,seedSalt=0){
  const ix=Math.floor(x), iy=Math.floor(y);
  const fx = x-ix, fy=y-iy;
  const a=hash01(ix,iy,seedSalt), b=hash01(ix+1,iy,seedSalt), c=hash01(ix,iy+1,seedSalt), d=hash01(ix+1,iy+1,seedSalt);
  const u = fx*fx*(3-2*fx), v = fy*fy*(3-2*fy);
  return lerp(lerp(a,b,u), lerp(c,d,u), v);
}
function pickBiome(cx,cy){ const v = smoothNoise(cx * NOISE_SCALE, cy * NOISE_SCALE, currentSeedNumber); if (v < 0.6) return 'grass'; if (v < 0.85) return 'desert'; return 'ice'; }

function keyFor(cx,cy){ return cx+','+cy; }
function ensureChunk(cx,cy){
  const key = keyFor(cx,cy);
  if (chunks.has(key)) return chunks.get(key);
  const seed = seedFromCoords(cx,cy);
  const rng = makeRNG(seed);
  const tiles = new Array(CHUNK_TILES*CHUNK_TILES);
  let mineCount = 0;
  for (let ty=0; ty<CHUNK_TILES; ty++){
    for (let tx=0; tx<CHUNK_TILES; tx++){
      const idx = ty*CHUNK_TILES + tx;
      const mine = rng() < MINE_PROB;
      if (mine) mineCount++;
      tiles[idx] = { mine, revealed:false, flagged:false, adj:0, exploded:false };
    }
  }
  for (let ty=0; ty<CHUNK_TILES; ty++){
    for (let tx=0; tx<CHUNK_TILES; tx++){
      let adj=0;
      for (let oy=-1; oy<=1; oy++) for (let ox=-1; ox<=1; ox++){
        if (ox===0 && oy===0) continue;
        const nx = tx+ox, ny = ty+oy;
        if (nx>=0 && nx<CHUNK_TILES && ny>=0 && ny<CHUNK_TILES){
          if (tiles[ny*CHUNK_TILES + nx].mine) adj++;
        }
      }
      tiles[ty*CHUNK_TILES + tx].adj = adj;
    }
  }
  const biome = pickBiome(cx,cy);
  const c = { cx, cy, tiles, generated:true, solved:false, disabled:false, reviveAvailable:true, mineCount, reviveTime:0, needsSolve:false, biome };
  chunks.set(key, c);
  return c;
}

/* tile helpers & gameplay (unchanged) */
function getTileAt(worldTileX, worldTileY){
  const cx = Math.floor(worldTileX / CHUNK_TILES), cy = Math.floor(worldTileY / CHUNK_TILES);
  const chunk = ensureChunk(cx, cy);
  const tx = ((worldTileX % CHUNK_TILES) + CHUNK_TILES) % CHUNK_TILES;
  const ty = ((worldTileY % CHUNK_TILES) + CHUNK_TILES) % CHUNK_TILES;
  return { chunk, tile: chunk.tiles[ty*CHUNK_TILES + tx], tx, ty, worldTx:worldTileX, worldTy:worldTileY };
}
function getAdj(worldTileX, worldTileY){
  let count = 0;
  for (let oy=-1; oy<=1; oy++) for (let ox=-1; ox<=1; ox++){
    if (ox===0 && oy===0) continue;
    const nt = getTileAt(worldTileX + ox, worldTileY + oy);
    if (nt.tile.mine) count++;
  }
  return count;
}
function clearMinesAround(wx,wy){ const affected = new Set(); for (let oy=-1; oy<=1; oy++) for (let ox=-1; ox<=1; ox++){ const nx = wx+ox, ny = wy+oy; const info = getTileAt(nx,ny); affected.add(keyFor(info.chunk.cx, info.chunk.cy)); if (info.tile.mine) info.tile.mine = false; } affected.forEach(k=>{ const [cx,cy] = k.split(',').map(Number); for (let ty=-1; ty<=CHUNK_TILES; ty++) for (let tx=-1; tx<=CHUNK_TILES; tx++){ const wx2 = cx*CHUNK_TILES + tx, wy2 = cy*CHUNK_TILES + ty; const info = getTileAt(wx2, wy2); if (info.tile.revealed) info.tile.adj = getAdjacencySafe(wx2, wy2); } }); }
function getAdjacencySafe(wx,wy){ let count=0; for (let oy=-1; oy<=1; oy++) for (let ox=-1; ox<=1; ox++){ if (ox===0 && oy===0) continue; const t = getTileAt(wx+ox, wy+oy); if (t.tile.mine) count++; } return count; }
function canRevealAt(worldTileX, worldTileY){ if (!firstClickDone) return true; for (let dy=-2; dy<=2; dy++){ for (let dx=-2; dx<=2; dx++){ const wx = worldTileX + dx, wy = worldTileY + dy; const info = getTileAt(wx, wy); if (info.tile.revealed) return true; } } return false; }
function revealTile(worldTileX, worldTileY){ if (!canRevealAt(worldTileX, worldTileY)) return; const info0 = getTileAt(worldTileX, worldTileY); const { chunk: c0, tile: t0 } = info0; if (c0.disabled) return; if (t0.flagged || t0.revealed) return; if (!firstClickDone){ clearMinesAround(worldTileX, worldTileY); firstClickDone = true; } if (t0.mine){ t0.exploded = true; t0.revealed = true; c0.disabled = true; c0.revealedDeath = { wx: worldTileX, wy: worldTileY }; updateNeedsSolve(); saveCurrent(); return; } const queue = [[worldTileX, worldTileY]]; const visited = new Set(); while (queue.length){ const [wx,wy] = queue.shift(); const key = wx+','+wy; if (visited.has(key)) continue; visited.add(key); const obj = getTileAt(wx, wy); const tchunk = obj.chunk; if (tchunk.disabled) continue; const tt = obj.tile; if (tt.revealed || tt.flagged) continue; tt.revealed = true; tt.adj = getAdj(wx, wy); if (tt.adj === 0){ for (let oy=-1; oy<=1; oy++) for (let ox=-1; ox<=1; ox++){ if (ox===0 && oy===0) continue; queue.push([wx+ox, wy+oy]); } } updateChunkSolved(tchunk); } updateNeedsSolve(); saveCurrent(); }

/* auto-flag & revive logic unchanged */
function autoFlagMinesInChunk(chunk){ for (let i=0;i<chunk.tiles.length;i++){ const t = chunk.tiles[i]; if (t.mine) t.flagged = true; } }
function onChunkSolved(chunk){ autoFlagMinesInChunk(chunk); for (const c of chunks.values()){ if (!c.disabled) continue; let allNeighborsSolved = true; for (let oy=-1; oy<=1; oy++) for (let ox=-1; ox<=1; ox++){ if (ox===0 && oy===0) continue; const n = ensureChunk(c.cx + ox, c.cy + oy); if (!n.solved) { allNeighborsSolved = false; break; } } if (allNeighborsSolved){ c.disabled = false; c.reviveTime = Date.now(); c.solved = false; for (const t of c.tiles) t.exploded = false; } } updateNeedsSolve(); }
function updateChunkSolved(chunk){ if (chunk.disabled){ chunk.solved = false; return; } let allRevealed = true; for (let i=0;i<chunk.tiles.length;i++){ const t = chunk.tiles[i]; if (!t.mine && !t.revealed){ allRevealed = false; break; } } const newlySolved = (!chunk.solved && allRevealed); chunk.solved = allRevealed; if (newlySolved) onChunkSolved(chunk); }
function toggleFlag(worldTileX, worldTileY){ const info = getTileAt(worldTileX, worldTileY); const { chunk, tile } = info; if (chunk.disabled) return; if (tile.revealed) return; tile.flagged = !tile.flagged; updateChunkSolved(chunk); updateNeedsSolve(); saveCurrent(); }
function updateNeedsSolve(){ for (const c of chunks.values()) c.needsSolve = false; for (const c of chunks.values()){ if (!c.disabled) continue; for (let oy=-1; oy<=1; oy++) for (let ox=-1; ox<=1; ox++){ if (ox===0 && oy===0) continue; const n = ensureChunk(c.cx + ox, c.cy + oy); if (!n.disabled) n.needsSolve = true; } } }

/* Rendering kept (omitted here for brevity in analysis ‚Äî still included in final) */
const NUMBER_COLORS = {1:'#264bb2',2:'#2d8a33',3:'#b22222',4:'#5b2a86',5:'#7a3e1e',6:'#2b7b7b',7:'#1d1d1d',8:'#5f6a73'};
function draw(){ /* full draw implementation (unchanged) */ ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,canvas.width,canvas.height); ctx.fillStyle = '#eaf8ef'; ctx.fillRect(0,0,canvas.width,canvas.height); const cssTile = DEFAULT_TILE * cam.scale; const tx = -cam.x * cssTile * DPR; const ty = -cam.y * cssTile * DPR; ctx.setTransform(DPR, 0, 0, DPR, tx, ty); const visibleLeft = cam.x - 2; const visibleTop  = cam.y - 2; const visibleRight = (canvas.width / DPR) / cssTile + cam.x + 2; const visibleBottom= (canvas.height / DPR) / cssTile + cam.y + 2; const startChunkX = Math.floor(visibleLeft / CHUNK_TILES); const endChunkX   = Math.floor(visibleRight / CHUNK_TILES); const startChunkY = Math.floor(visibleTop / CHUNK_TILES); const endChunkY   = Math.floor(visibleBottom / CHUNK_TILES); const chunkCount = (endChunkX - startChunkX + 1) * (endChunkY - startChunkY + 1); const tileW_canvas = Math.max(1, Math.round(cssTile * DPR)); const heavySimplify = (tileW_canvas <= 5 * DPR && chunkCount > 200); for (let ccx = startChunkX; ccx <= endChunkX; ccx++){ for (let ccy = startChunkY; ccy <= endChunkY; ccy++){ const chunk = ensureChunk(ccx, ccy); if (heavySimplify) drawChunkMinimized(chunk, cssTile); else drawChunk(chunk, cssTile); } } if (tileW_canvas > 8) drawGlobalChunkGrid(startChunkX, startChunkY, endChunkX, endChunkY, cssTile); drawMergedNeedsSolveOutlines(startChunkX, startChunkY, endChunkX, endChunkY, cssTile); ctx.save(); ctx.globalCompositeOperation = 'multiply'; ctx.fillStyle = `rgba(250,255,250,0.06)`; ctx.fillRect(cam.x * cssTile - 10000, cam.y * cssTile - 10000, (canvas.width / DPR) + 20000, (canvas.height / DPR) + 20000); ctx.restore(); ctx.setTransform(1,0,0,1,0,0); requestAnimationFrame(draw); }
function drawChunkMinimized(chunk, tileW){ /* ... same as before ... (omitted here for brevity) */ const chunkX = chunk.cx * CHUNK_TILES * tileW; const chunkY = chunk.cy * CHUNK_TILES * tileW; const chunkW = tileW * CHUNK_TILES; let chunkBg = '#e6f7dc'; let covered = '#d1eac0'; let revealed = '#f7fff5'; if (chunk.biome === 'desert'){ chunkBg = '#fff0d6'; covered = '#f5e7b2'; revealed = '#fff7e0'; } else if (chunk.biome === 'ice'){ chunkBg = '#f7fbff'; covered = '#eaf4ff'; revealed = '#ffffff'; } ctx.fillStyle = chunk.disabled ? '#ffd7d9' : chunkBg; ctx.fillRect(chunkX, chunkY, chunkW, chunkW); if (chunk.disabled){ ctx.fillStyle = 'rgba(200,20,20,0.95)'; ctx.fillRect(chunkX, chunkY, chunkW, chunkW); } ctx.fillStyle = '#c33'; for (let i=0;i<chunk.tiles.length;i++){ const t = chunk.tiles[i]; if (!t.flagged) continue; const tx = i % CHUNK_TILES, ty = Math.floor(i/CHUNK_TILES); const x = chunkX + tx*tileW, y = chunkY + ty*tileW; if (tileW >= 6){ ctx.font = `${Math.floor(tileW*0.8)}px system-ui`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('üö©', x + tileW/2, y + tileW/2); } else { ctx.fillRect(x+1, y+1, Math.max(1, tileW-2), Math.max(1, tileW-2)); } } for (let i = 0; i < chunk.tiles.length; i++){ const t = chunk.tiles[i]; if (!t.revealed && t.exploded){ const tx = i % CHUNK_TILES, ty = Math.floor(i/CHUNK_TILES); const x = chunkX + tx*tileW, y = chunkY + ty*tileW; ctx.font = `${Math.max(8,Math.floor(tileW*0.9))}px system-ui`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillStyle = '#fff'; ctx.fillText('üí£', x + tileW/2, y + tileW/2); } } }
function drawChunk(chunk, tileW){ /* ... same as before ... code preserved ... */ let chunkX = chunk.cx * CHUNK_TILES * tileW, chunkY = chunk.cy * CHUNK_TILES * tileW, chunkW = tileW * CHUNK_TILES; let chunkBg = '#e6f7dc', covered = '#d1eac0', revealed = '#f7fff5'; let grassColors = ["#dff7d9","#e7f8de","#e0f3d6","#f0f9e6"]; let numberOverrideToBlack = false; let iceSpecial = false; if (chunk.biome === 'desert'){ chunkBg = '#fff0d6'; covered = '#f5e7b2'; revealed = '#fff7e0'; grassColors = ["#f2e6b6","#f6e9c0","#efe1a8"]; numberOverrideToBlack = true; } else if (chunk.biome === 'ice'){ chunkBg = '#f7fbff'; covered = '#eaf4ff'; revealed = '#ffffff'; grassColors = ["#f7fbff","#eef6ff","#f0f9ff"]; iceSpecial = true; } ctx.fillStyle = chunk.disabled ? '#e9efe0' : chunkBg; ctx.fillRect(chunkX, chunkY, chunkW, chunkW); const simplified = tileW <= 12; if (simplified){ drawChunkMinimized(chunk, tileW); if (chunk.disabled){ ctx.fillStyle='rgba(40,40,40,0.28)'; ctx.fillRect(chunkX,chunkY,chunkW,chunkW); ctx.fillStyle='#fff'; ctx.font=`${Math.max(12,Math.floor(chunkW/4))}px system-ui`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('üíÄ', chunkX + chunkW/2, chunkY + chunkW/2); } else if (chunk.solved){ ctx.fillStyle='rgba(40,40,40,0.12)'; ctx.fillRect(chunkX,chunkY,chunkW,chunkW); } return; } for (let ty=0; ty<CHUNK_TILES; ty++){ for (let tx=0; tx<CHUNK_TILES; tx++){ const t = chunk.tiles[ty*CHUNK_TILES + tx]; const x = chunkX + tx*tileW, y = chunkY + ty*tileW; ctx.fillStyle = grassColors[(Math.abs(chunk.cx*7 + chunk.cy*11 + tx*3 + ty*5) % grassColors.length)]; ctx.fillRect(x, y, tileW-1, tileW-1); if (t.revealed){ if (iceSpecial){ ctx.fillStyle = covered; ctx.fillRect(x+1,y+1,tileW-2,tileW-2); } else { ctx.fillStyle = (t.adj === 0) ? revealed : revealed; ctx.fillRect(x+2,y+2,tileW-4,tileW-4); } if (t.mine){ if (t.exploded){ ctx.fillStyle = '#fff'; ctx.font = `${Math.max(12,Math.floor(tileW*0.9))}px system-ui`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('üí£', x+tileW/2, y+tileW/2); } else { ctx.fillStyle = '#222'; ctx.beginPath(); ctx.arc(x+tileW/2,y+tileW/2,tileW*0.22,0,Math.PI*2); ctx.fill(); } } else if (t.adj > 0){ const fontsize = Math.max(10, Math.floor(tileW*0.55)); ctx.font = `700 ${fontsize}px "Segoe UI Rounded", "Helvetica Neue", Arial, system-ui`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.lineWidth = Math.max(1, DPR*0.7) / DPR; ctx.strokeStyle = 'rgba(255,255,255,0.9)'; const numColor = numberOverrideToBlack ? '#000' : (NUMBER_COLORS[t.adj] || '#000'); ctx.strokeText(t.adj, x + tileW/2, y + tileW/2 + (DPR*0.3)/DPR); ctx.fillStyle = numColor; ctx.fillText(t.adj, x + tileW/2, y + tileW/2 + (DPR*0.3)/DPR); } } else { ctx.fillStyle = covered; ctx.fillRect(x+1,y+1,tileW-2,tileW-2); ctx.fillStyle = 'rgba(255,255,255,0.06)'; ctx.fillRect(x+1,y+1,tileW/2,tileW/6); if (t.flagged){ ctx.font = `${Math.floor(tileW*0.9)}px system-ui`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('üö©', x+tileW/2, y+tileW/2); } } } } if (chunk.disabled){ ctx.fillStyle = 'rgba(60,10,10,0.22)'; ctx.fillRect(chunkX, chunkY, chunkW, chunkW); ctx.fillStyle = '#fff'; ctx.font = `${Math.max(18,Math.floor(chunkW/6))}px "Segoe UI", system-ui`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('üíÄ', chunkX + chunkW/2, chunkY + chunkW/2); for (let ty=0; ty<CHUNK_TILES; ty++){ for (let tx=0; tx<CHUNK_TILES; tx++){ const t = chunk.tiles[ty*CHUNK_TILES + tx]; if (t.revealed && t.adj > 0 && !t.mine){ const x = chunkX + tx*tileW, y = chunkY + ty*tileW; const fontsize = Math.max(10, Math.floor(tileW*0.55)); ctx.font = `700 ${fontsize}px "Segoe UI Rounded", "Helvetica Neue", Arial, system-ui`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.lineWidth = Math.max(1, DPR*0.7) / DPR; ctx.strokeStyle = 'rgba(255,255,255,0.9)'; const numColor = numberOverrideToBlack ? '#000' : (NUMBER_COLORS[t.adj] || '#000'); ctx.strokeText(t.adj, x + tileW/2, y + tileW/2 + (DPR*0.3)/DPR); ctx.fillStyle = numColor; ctx.fillText(t.adj, x + tileW/2, y + tileW/2 + (DPR*0.3)/DPR); } } } } else if (chunk.solved){ ctx.fillStyle = 'rgba(40,40,40,0.12)'; ctx.fillRect(chunkX, chunkY, chunkW, chunkW); } if (chunk.reviveTime && (Date.now() - chunk.reviveTime) <= 2200){ drawRectBorder(chunkX, chunkY, chunkW, chunkW, '#d33', Math.max(1 / DPR, 1 / DPR)); } }
function drawGlobalChunkGrid(startChunkX, startChunkY, endChunkX, endChunkY, tileW){ const borderCss = Math.max(1 / DPR, 0.5 / DPR); ctx.fillStyle = `rgba(0,0,0,0.04)`; const topY = startChunkY * CHUNK_TILES * tileW; const height = (endChunkY - startChunkY + 1) * CHUNK_TILES * tileW; for (let cx = startChunkX; cx <= endChunkX + 1; cx++){ const x = cx * CHUNK_TILES * tileW; ctx.fillRect(x, topY, borderCss, height); } const leftX = startChunkX * CHUNK_TILES * tileW; const width = (endChunkX - startChunkX + 1) * CHUNK_TILES * tileW; for (let cy = startChunkY; cy <= endChunkY + 1; cy++){ const y = cy * CHUNK_TILES * tileW; ctx.fillRect(leftX, y, width, borderCss); } }
function drawMergedNeedsSolveOutlines(startChunkX, startChunkY, endChunkX, endChunkY, tileW){ const filled = new Set(); for (let cx = startChunkX; cx <= endChunkX; cx++){ for (let cy = startChunkY; cy <= endChunkY; cy++){ const chunk = ensureChunk(cx, cy); if (chunk.needsSolve) filled.add(`${cx},${cy}`); } } if (filled.size === 0) return; const edgeMap = new Map(); function addEdge(ax,ay,bx,by){ const a=`${ax},${ay}`, b=`${bx},${by}`; if (!edgeMap.has(a)) edgeMap.set(a,new Set()); if (!edgeMap.has(b)) edgeMap.set(b,new Set()); edgeMap.get(a).add(b); edgeMap.get(b).add(a); } for (const s of filled){ const [cx,cy] = s.split(',').map(Number); if (!filled.has(`${cx},${cy-1}`)) addEdge(cx,cy, cx+1,cy); if (!filled.has(`${cx+1},${cy}`)) addEdge(cx+1,cy, cx+1,cy+1); if (!filled.has(`${cx},${cy+1}`)) addEdge(cx+1,cy+1, cx,cy+1); if (!filled.has(`${cx-1},${cy}`)) addEdge(cx,cy+1, cx,cy); } const loops = []; const used = new Set(); for (const [pt, nset] of edgeMap.entries()){ for (const nb of nset){ const ekey = pt+'->'+nb; if (used.has(ekey)) continue; const loop = []; let cur = pt, prev = null; while (true){ loop.push(cur); const nbs = Array.from(edgeMap.get(cur) || []); let next = null; for (const cand of nbs){ const candKey = cur + '->' + cand; if (used.has(candKey)) continue; if (cand === prev) continue; next = cand; break; } if (!next){ for (const cand of nbs){ const candKey = cur + '->' + cand; if (!used.has(candKey)){ next = cand; break; } } } if (!next) break; used.add(cur + '->' + next); prev = cur; cur = next; if (cur === loop[0]) break; if (loop.length > 10000) break; } if (loop.length > 1) loops.push(loop.map(p => p.split(',').map(Number))); } } ctx.lineWidth = Math.max(2/DPR, 1/DPR); ctx.strokeStyle = '#d33'; ctx.fillStyle = 'rgba(220,40,40,0.02)'; for (const poly of loops){ if (poly.length < 2) continue; ctx.beginPath(); const chunkPixels = CHUNK_TILES * tileW; for (let i=0;i<poly.length;i++){ const [gx,gy] = poly[i]; const px = gx * chunkPixels, py = gy * chunkPixels; if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py); } ctx.closePath(); ctx.fill(); ctx.stroke(); } }
function drawRectBorder(x,y,w,h,color,thickness){ ctx.fillStyle = color; ctx.fillRect(x, y, w, thickness); ctx.fillRect(x, y + h - thickness, w, thickness); ctx.fillRect(x, y, thickness, h); ctx.fillRect(x + w - thickness, y, thickness, h); }

/* start drawing loop */
draw();

/* ===== Input handling & autosave (unchanged behavior; saveCurrent used) ===== */
const pointers = new Map();
let pinchState = null;
let pointerDownInfo = {};
let isPinching=false, isPanning=false, lastPanTime=0;
function clientToLogical(clientX,clientY){ const rect = canvas.getBoundingClientRect(); const cx = (clientX - rect.left); const cy = (clientY - rect.top); return { logicalX: cx, logicalY: cy }; }
function getDistance(a,b){ const dx=a.clientX-b.clientX, dy=a.clientY-b.clientY; return Math.hypot(dx,dy); }
function computeCentroid(mapLike){ let sx=0,sy=0,n=0; for(const v of mapLike.values()){ sx+=v.clientX; sy+=v.clientY; n++; } if(n===0) return null; return { clientX:sx/n, clientY:sy/n }; }

document.addEventListener('contextmenu', (e)=>{ e.preventDefault(); });

function handlePointerDown(e){
  canvas.setPointerCapture && canvas.setPointerCapture(e.pointerId);
  pointers.set(e.pointerId, { clientX: e.clientX, clientY: e.clientY });
  pointerDownInfo[e.pointerId] = { startClientX: e.clientX, startClientY: e.clientY, startTime: Date.now(), moved:false, panned:false };
  if (pointers.size === 2){
    isPinching = true;
    const arr = Array.from(pointers.values());
    pinchState = { startDist: getDistance(arr[0], arr[1]), startScale: cam.scale };
    const midClientX = (arr[0].clientX + arr[1].clientX)/2;
    const midClientY = (arr[0].clientY + arr[1].clientY)/2;
    const logical = clientToLogical(midClientX, midClientY);
    const cssTile = DEFAULT_TILE * cam.scale;
    pinchState.startMidWorldTileX = (logical.logicalX / cssTile) + cam.x;
    pinchState.startMidWorldTileY = (logical.logicalY / cssTile) + cam.y;
  }
  saveCurrent(); // immediate save attempt (will fall back to idb on quota errors)
}

function handlePointerMove(e){
  if (!pointers.has(e.pointerId)) return;
  const prevCentroid = computeCentroid(pointers);
  const prev = pointers.get(e.pointerId);
  const dxClient = e.clientX - prev.clientX, dyClient = e.clientY - prev.clientY;
  pointers.set(e.pointerId, { clientX: e.clientX, clientY: e.clientY });

  const logicalDx = dxClient;
  const logicalDy = dyClient;
  if (pointerDownInfo[e.pointerId] && (Math.abs(logicalDx) > 0.5 || Math.abs(logicalDy) > 0.5)) pointerDownInfo[e.pointerId].moved = true;
  const newCentroid = computeCentroid(pointers);

  const cssTile = DEFAULT_TILE * cam.scale;

  if (pointers.size >= 2){
    if (prevCentroid && newCentroid){
      const centroidDxClient = newCentroid.clientX - prevCentroid.clientX;
      const centroidDyClient = newCentroid.clientY - prevCentroid.clientY;
      const centroidLogicalDx = centroidDxClient;
      const centroidLogicalDy = centroidDyClient;
      if (Math.hypot(centroidLogicalDx, centroidLogicalDy) >= 3){
        isPanning = true; lastPanTime = Date.now();
        for (const id in pointerDownInfo) if (pointerDownInfo.hasOwnProperty(id)) pointerDownInfo[id].panned = true;
      }
      if (!pinchState) {
        cam.x -= centroidLogicalDx / cssTile;
        cam.y -= centroidLogicalDy / cssTile;
      }
    }
    if (pinchState && pointers.size >= 2){
      const arr = Array.from(pointers.values());
      const a = arr[0], b = arr[1];
      const dist = getDistance(a,b);
      const ratio = dist / pinchState.startDist;
      const newScale = Math.min(3, Math.max(0.12, pinchState.startScale * ratio));
      const midClientX = (a.clientX + b.clientX)/2;
      const midClientY = (a.clientY + b.clientY)/2;
      const logicalMid = clientToLogical(midClientX, midClientY);
      cam.x = pinchState.startMidWorldTileX - (logicalMid.logicalX / (DEFAULT_TILE * newScale));
      cam.y = pinchState.startMidWorldTileY - (logicalMid.logicalY / (DEFAULT_TILE * newScale));
      cam.scale = newScale;
    }
    return;
  }

  if (pointers.size === 1 && !pinchState){
    if (Math.hypot(logicalDx, logicalDy) >= 3){
      isPanning = true; lastPanTime = Date.now(); if (pointerDownInfo[e.pointerId]) pointerDownInfo[e.pointerId].panned = true;
    }
    const cssTileNow = DEFAULT_TILE * cam.scale;
    cam.x -= logicalDx / cssTileNow;
    cam.y -= logicalDy / cssTileNow;
  }
}

function handlePointerUp(e){
  canvas.releasePointerCapture && canvas.releasePointerCapture(e.pointerId);
  const down = pointerDownInfo[e.pointerId];
  const now = Date.now();
  const startClientX = down ? down.startClientX : e.clientX;
  const startClientY = down ? down.startClientY : e.clientY;
  const startTime = down ? down.startTime : now;
  const endClientX = e.clientX, endClientY = e.clientY;
  const moveLogicalX = (endClientX - startClientX);
  const moveLogicalY = (endClientY - startClientY);
  const moveDist = Math.hypot(moveLogicalX, moveLogicalY);
  const timeDelta = now - startTime;

  const pointerMarkedPanned = !!(down && down.panned);
  const panHappenedRecently = (now - lastPanTime) <= 140;
  const pointerMoved = !!(down && down.moved);
  const wasPinching = isPinching;

  pointers.delete(e.pointerId);
  delete pointerDownInfo[e.pointerId];

  if (pointers.size < 2) { pinchState = null; isPinching = false; }

  const suppressedByPan = pointerMarkedPanned || panHappenedRecently || isPanning;
  const allowTap = !suppressedByPan && !pointerMoved && moveDist <= 8 && timeDelta <= 400 && !wasPinching && pointers.size === 0;

  if (pointers.size === 0) setTimeout(()=>{ isPanning = false; }, 0);

  if (allowTap){
    const logical = clientToLogical(endClientX, endClientY);
    const cssTileNow = DEFAULT_TILE * cam.scale;
    const wx = Math.floor((logical.logicalX / cssTileNow) + cam.x);
    const wy = Math.floor((logical.logicalY / cssTileNow) + cam.y);
    if (mode === 'shovel') revealTile(wx, wy);
    else toggleFlag(wx, wy);
  }
  saveCurrent();
}

canvas.addEventListener('pointerdown', handlePointerDown);
canvas.addEventListener('pointermove', handlePointerMove, { passive:false });
canvas.addEventListener('pointerup', handlePointerUp);
canvas.addEventListener('pointercancel', handlePointerUp);
canvas.addEventListener('pointerout', handlePointerUp);
canvas.addEventListener('pointerleave', handlePointerUp);
canvas.addEventListener('dblclick', (e)=>e.preventDefault());

/* ===== UI and world menu logic (only minimal changes) ===== */
const overlay = document.getElementById('overlay');
const btnNew = document.getElementById('btnNew'), btnLoad = document.getElementById('btnLoad'), btnSettings = document.getElementById('btnSettings'), btnHow = document.getElementById('btnHow');
const panelNew = document.getElementById('panelNew'), panelLoad = document.getElementById('panelLoad'), panelSettings = document.getElementById('panelSettings'), panelHow = document.getElementById('panelHow');
const mainActions = document.getElementById('mainActions');
const btnResume = document.getElementById('btnResume'), btnSave = document.getElementById('btnSave');
const createBtn = document.getElementById('createBtn'), cancelNew = document.getElementById('cancelNew');
const cancelLoad = document.getElementById('cancelLoad'), cancelSettings = document.getElementById('cancelSettings'), cancelHow = document.getElementById('cancelHow');
const newName = document.getElementById('newName'), newSeed = document.getElementById('newSeed');
const worldListEl = document.getElementById('worldList');
const pauseBtn = document.getElementById('pauseBtn');
const shovelBtn = document.getElementById('shovelBtn'), flagBtn = document.getElementById('flagBtn'), reviveBtn = document.getElementById('reviveBtn');

let mode = 'shovel';
function updateToolUI(){ shovelBtn.classList.toggle('active', mode==='shovel'); flagBtn.classList.toggle('active', mode==='flag'); }
updateToolUI();

/* track how overlay was opened; if opened via pause button, show Save next to Resume */
let lastOverlaySource = null;
function openOverlay(source){
  lastOverlaySource = source || null;
  overlay.style.display='flex';
  overlay.setAttribute('aria-hidden','false');
  showMain();
  updateSelectedWorldInfo();
  updateResumeVisibility();
}
function closeOverlay(){ overlay.style.display='none'; overlay.setAttribute('aria-hidden','true'); }
function showMain(){ mainActions.style.display='block'; panelNew.style.display='none'; panelLoad.style.display='none'; panelSettings.style.display='none'; panelHow.style.display='none'; updateSelectedWorldInfo(); updateResumeVisibility(); }
function showNew(){ mainActions.style.display='none'; panelNew.style.display='block'; panelLoad.style.display='none'; panelSettings.style.display='none'; panelHow.style.display='none'; }
function showLoad(){ mainActions.style.display='none'; panelNew.style.display='none'; panelLoad.style.display='block'; panelSettings.style.display='none'; panelHow.style.display='none'; refreshWorldList(); }
function showSettings(){ mainActions.style.display='none'; panelNew.style.display='none'; panelLoad.style.display='none'; panelSettings.style.display='block'; }
function showHow(){ mainActions.style.display='none'; panelNew.style.display='none'; panelLoad.style.display='none'; panelSettings.style.display='none'; panelHow.style.display='block'; }

btnNew.addEventListener('click', ()=>{ showNew(); });
btnLoad.addEventListener('click', ()=>{ showLoad(); });
btnSettings.addEventListener('click', ()=>{ showSettings(); });
btnHow.addEventListener('click', ()=>{ showHow(); });
pauseBtn.addEventListener('click', ()=>{ openOverlay('pause'); });

btnResume.addEventListener('click', ()=>{ if (currentWorldId) closeOverlay(); else alert('Please create or load a world first.'); });
btnSave.addEventListener('click', ()=>{ if (!currentWorldId) { alert('No world to save.'); return; } saveCurrent(); });

cancelNew.addEventListener('click', ()=> showMain());
cancelLoad.addEventListener('click', ()=> showMain());
cancelSettings.addEventListener('click', ()=> showMain());
cancelHow.addEventListener('click', ()=> showMain());

createBtn.addEventListener('click', ()=>{
  const name = (newName.value || 'World').trim();
  let seed = (newSeed.value || '').trim();
  if (!seed) seed = 'seed-' + Math.floor(Math.random()*1e9);
  createWorld(name, seed);
  newName.value=''; newSeed.value='';
  closeOverlay();
});

function createWorld(name, seed){
  const id = Date.now().toString(36) + '-' + Math.floor(Math.random()*1e6).toString(36);
  const rec = { id, name, seed, createdAt: Date.now(), lastPlayed: Date.now() };
  worlds.unshift(rec); saveWorldMeta(); loadWorldById(id);
}

function refreshWorldList(){
  worldListEl.innerHTML = '';
  if (worlds.length === 0){ worldListEl.innerHTML = '<div class="smallNote">No worlds yet ‚Äî create one.</div>'; return; }
  for (const w of worlds){
    const card = document.createElement('div'); card.className = 'worldCard';
    const left = document.createElement('div'); left.className = 'worldLeft';
    const title = document.createElement('div'); title.className = 'worldTitle'; title.textContent = w.name;
    const seed = document.createElement('div'); seed.className = 'worldSeed'; seed.textContent = 'seed: ' + w.seed;
    left.appendChild(title); left.appendChild(seed);

    // If overlay was opened from pause and this is the current world, mark as playing
    if (lastOverlaySource === 'pause' && currentWorldId && w.id === currentWorldId){
      const playing = document.createElement('div'); playing.className = 'playingBadge'; playing.textContent = 'Playing';
      left.appendChild(playing);
    }

    const actions = document.createElement('div'); actions.className = 'worldActions';
    const load = document.createElement('button'); load.className='secondaryBtn'; load.textContent='Play'; load.addEventListener('click', ()=>{ loadWorldById(w.id); closeOverlay(); });
    const rename = document.createElement('button'); rename.className='secondaryBtn'; rename.textContent='Rename'; rename.addEventListener('click', ()=>{ const nn = prompt('Rename', w.name); if (nn){ w.name = nn; saveWorldMeta(); refreshWorldList(); updateSelectedWorldInfo(); }});
    const del = document.createElement('button'); del.className='secondaryBtn'; del.textContent='Delete'; del.addEventListener('click', ()=>{ if (confirm('Delete "'+w.name+'"?')){ deleteWorld(w.id); refreshWorldList(); }});
    actions.appendChild(load); actions.appendChild(rename); actions.appendChild(del);
    card.appendChild(left); card.appendChild(actions); worldListEl.appendChild(card);
  }
}

function deleteWorld(id){ worlds = worlds.filter(w => w.id !== id); saveWorldMeta(); try{ localStorage.removeItem(SAVE_PREFIX + id); }catch(e){} try { /* also remove idb entry */ openIdb().then(db=>{ const tx=db.transaction('saves','readwrite'); tx.objectStore('saves').delete(id); db.close(); }).catch(()=>{}); } catch(e){} if (currentWorldId === id){ currentWorldId = null; currentSeedString=''; currentSeedNumber=0; chunks.clear(); } updateSelectedWorldInfo(); updateResumeVisibility(); }

function loadWorldById(id){
  const w = worlds.find(x=>x.id===id); if (!w) return;
  currentWorldId = w.id; currentSeedString = w.seed; currentSeedNumber = hashStringToNumber(currentSeedString);
  w.lastPlayed = Date.now(); saveWorldMeta();
  chunks.clear(); firstClickDone = false;
  const raw = localStorage.getItem(SAVE_PREFIX + id);
  if (raw){
    try{
      const obj = JSON.parse(raw);
      if (obj.camera) cam = obj.camera;
      if (obj.firstClickDone) firstClickDone = true;
      if (obj.chunks && Array.isArray(obj.chunks)){
        for (const c of obj.chunks){
          const tiles = c.tiles.map(t => ({ mine: !!t.mine, revealed: !!t.revealed, flagged: !!t.flagged, adj: t.adj || 0, exploded: !!t.exploded }));
          const rec = { cx: c.cx, cy: c.cy, tiles, generated:true, solved: !!c.solved, disabled: !!c.disabled, reviveAvailable: !!c.reviveAvailable, mineCount: c.mineCount || 0, reviveTime: c.reviveTime || 0, needsSolve: !!c.needsSolve, biome: c.biome || pickBiome(c.cx,c.cy) };
          chunks.set(keyFor(c.cx,c.cy), rec);
        }
      }
      lastSaveMethod = 'localStorage';
      lastSaveKey = SAVE_PREFIX + id;
      lastSavedAt = Date.now();
    }catch(e){ console.warn('Load failed, starting fresh'); }
  } else {
    cam = { x:0, y:0, scale:1 };
    // Try to load from IDB if available
    idbGet(id).then(rawIdb=>{
      if (rawIdb){
        try{
          const obj = JSON.parse(rawIdb);
          if (obj.camera) cam = obj.camera;
          if (obj.firstClickDone) firstClickDone = true;
          if (obj.chunks && Array.isArray(obj.chunks)){
            for (const c of obj.chunks){
              const tiles = c.tiles.map(t => ({ mine: !!t.mine, revealed: !!t.revealed, flagged: !!t.flagged, adj: t.adj || 0, exploded: !!t.exploded }));
              const rec = { cx: c.cx, cy: c.cy, tiles, generated:true, solved: !!c.solved, disabled: !!c.disabled, reviveAvailable: !!c.reviveAvailable, mineCount: c.mineCount || 0, reviveTime: c.reviveTime || 0, needsSolve: !!c.needsSolve, biome: c.biome || pickBiome(c.cx,c.cy) };
              chunks.set(keyFor(c.cx,c.cy), rec);
            }
          }
          lastSaveMethod = 'indexedDB';
          lastSaveKey = 'idb:' + id;
          lastSavedAt = Date.now();
          updateSelectedWorldInfo();
        }catch(e){ console.warn('IDB load parse failed', e); }
      }
    }).catch(()=>{});
  }
  updateNeedsSolve(); updateSelectedWorldInfo(); updateResumeVisibility();
}

function updateSelectedWorldInfo(){
  const el = document.getElementById('selectedWorldInfo');
  if (!currentWorldId){ el.textContent = 'No world selected'; } else { const w = worlds.find(x=>x.id===currentWorldId); el.textContent = `Selected: ${w ? w.name : currentWorldId} (seed: ${currentSeedString})`; }
}

function updateResumeVisibility(){
  if (currentWorldId) btnResume.style.display = 'inline-block'; else btnResume.style.display = 'none';
  // Show Save button only when overlay opened from pause button
  if (lastOverlaySource === 'pause' && currentWorldId){
    btnSave.style.display = 'inline-block';
  } else {
    btnSave.style.display = 'none';
  }
}

/* ---------- saving with IndexedDB fallback ---------- */
function serializeChunks(){
  const arr = [];
  for (const [k,c] of chunks.entries()){
    arr.push({ cx:c.cx, cy:c.cy, biome:c.biome, disabled:!!c.disabled, reviveAvailable:!!c.reviveAvailable, mineCount:c.mineCount, solved:!!c.solved, reviveTime:c.reviveTime||0, needsSolve:!!c.needsSolve, tiles: c.tiles.map(t=>({ mine:!!t.mine, revealed:!!t.revealed, flagged:!!t.flagged, adj: t.adj||0, exploded:!!t.exploded })) });
  }
  return arr;
}

function saveCurrent(){
  if (!currentWorldId) return;
  try{
    const payloadObj = { camera: cam, firstClickDone: !!firstClickDone, chunks: serializeChunks(), t: Date.now() };
    const s = JSON.stringify(payloadObj);

    // Try to write to localStorage first
    try {
      localStorage.setItem(SAVE_PREFIX + currentWorldId, s);
      lastSaveError = null;
      lastSavedAt = Date.now();
      lastSaveSize = new Blob([s]).size;
      lastSaveKey = SAVE_PREFIX + currentWorldId;
      lastSaveMethod = 'localStorage';
      return;
    } catch (eLocal) {
      // If localStorage fails (quota exceeded, etc.), record and fall back to IDB
      lastSaveError = eLocal && eLocal.message ? (eLocal.message + (eLocal.stack ? '\n' + eLocal.stack : '')) : String(eLocal);
      lastSavedAt = Date.now();
      lastSaveSize = 0;
      lastSaveKey = SAVE_PREFIX + currentWorldId;
      lastSaveMethod = 'localStorage-error';

      // attempt IndexedDB fallback (async)
      idbPut(currentWorldId, s).then(()=>{
        lastSaveMethod = 'indexedDB';
        lastSaveKey = 'idb:' + currentWorldId;
        lastSavedAt = Date.now();
        try { lastSaveSize = new Blob([s]).size; } catch(_) { lastSaveSize = 0; }
        // update console
        renderConsoleAppend('\nSaved fallback to IndexedDB (idb:' + currentWorldId + ')');
      }).catch((eIdb)=>{
        lastSaveError = (eIdb && eIdb.message) ? (eIdb.message + (eIdb.stack ? '\n' + eIdb.stack : '')) : String(eIdb);
        renderConsoleAppend('\nIndexedDB fallback failed: ' + lastSaveError);
      });

      return;
    }
  } catch(e){
    lastSaveError = (e && e.message) ? (e.message + (e.stack ? '\n' + e.stack : '')) : String(e);
    lastSavedAt = Date.now();
    lastSaveSize = 0;
    lastSaveKey = SAVE_PREFIX + currentWorldId;
    console.warn('Save failed', e);
  }
}
function scheduleImmediateSave(){ saveCurrent(); }
setInterval(saveCurrent, 3000);
window.addEventListener('beforeunload', saveCurrent);

/* flashSaved intentionally removed per request */

/* initial overlay behavior */
if (worlds.length === 0){
  openOverlay(); showHow();
  document.getElementById('newSeed').value = 'seed-' + Math.floor(Math.random()*1e9);
} else {
  openOverlay(); showMain();
  updateSelectedWorldInfo();
}

/* expose debug */
window.__ims = { worlds, chunks, loadWorldById, createWorld, saveCurrent, cam };

/* =====================
   In-page developer console + key sequence detection
   Sequence: c o n s o l e (case-insensitive)
   ===================== */

const consoleSeq = 'console';
let consoleIndex = 0;
document.addEventListener('keydown', (ev) => {
  const k = (ev.key || '').toLowerCase();
  if (!k) return;
  if (k === consoleSeq[consoleIndex]) {
    consoleIndex++;
    if (consoleIndex >= consoleSeq.length) {
      consoleIndex = 0;
      toggleDevConsole(true);
    }
  } else {
    consoleIndex = (k === consoleSeq[0]) ? 1 : 0;
  }
});

const devConsole = document.getElementById('devConsole');
const consoleOutput = document.getElementById('consoleOutput');
const btnConsoleClose = document.getElementById('btnConsoleClose');
const btnConsoleSaveTest = document.getElementById('btnConsoleSaveTest');
const btnConsoleListKeys = document.getElementById('btnConsoleListKeys');
const btnConsoleDownload = document.getElementById('btnConsoleDownload');
const btnConsoleCopy = document.getElementById('btnConsoleCopy');

btnConsoleClose.addEventListener('click', ()=> toggleDevConsole(false));
btnConsoleSaveTest.addEventListener('click', runSaveTest);
btnConsoleListKeys.addEventListener('click', listSaveKeys);
btnConsoleDownload.addEventListener('click', downloadCurrentSave);
btnConsoleCopy.addEventListener('click', copyConsoleLog);

function toggleDevConsole(show){
  if (show) {
    devConsole.style.display = 'flex';
    devConsole.setAttribute('aria-hidden','false');
    renderConsole();
  } else {
    devConsole.style.display = 'none';
    devConsole.setAttribute('aria-hidden','true');
  }
}

function renderConsole(){
  const lines = [];
  lines.push(`=== Save diagnostics (${new Date().toLocaleString()}) ===`);
  lines.push(`currentWorldId: ${currentWorldId || '(none)'}`);
  lines.push(`currentSeedString: ${currentSeedString || '(none)'}`);
  lines.push(`SAVE key prefix: ${SAVE_PREFIX}`);
  lines.push(`Worlds metadata key: ${WORLDS_KEY}`);
  lines.push('');
  try {
    const testKey = '__ims_test__';
    localStorage.setItem(testKey, '1');
    localStorage.removeItem(testKey);
    lines.push('localStorage: AVAILABLE');
  } catch (e) {
    lines.push('localStorage: UNAVAILABLE ‚Äî ' + (e && e.message ? e.message : String(e)));
  }

  lines.push(`lastSavedAt: ${ lastSavedAt ? new Date(lastSavedAt).toLocaleString() : '(never)' }`);
  lines.push(`lastSaveKey: ${ lastSaveKey || '(none)' }`);
  lines.push(`lastSaveMethod: ${ lastSaveMethod || '(none)' }`);
  lines.push(`lastSaveSize (bytes): ${ lastSaveSize || 0 }`);
  lines.push(`lastSaveError: ${ lastSaveError ? ('ERROR: ' + lastSaveError) : '(none)' }`);
  lines.push('');
  lines.push('Quick checks:');
  lines.push(`- Number of known world entries: ${worlds.length}`);
  lines.push(`- Keys in localStorage (matching prefix or index):`);
  try {
    const keys = [];
    for (let i=0;i<localStorage.length;i++){
      const k = localStorage.key(i);
      if (!k) continue;
      if (k.indexOf(SAVE_PREFIX) === 0 || k === WORLDS_KEY || (currentWorldId && k.indexOf(currentWorldId) !== -1)) keys.push(k);
    }
    if (keys.length === 0) lines.push('  (no save keys found)');
    else keys.forEach(k => lines.push('  ' + k));
  } catch(e) {
    lines.push('  (cannot enumerate localStorage: ' + (e && e.message ? e.message : String(e)) + ')');
  }

  consoleOutput.textContent = lines.join('\n');

  // also append IDB keys matching currentWorldId (async)
  idbListKeysContaining(currentWorldId).then(keys=>{
    if (keys && keys.length){
      renderConsoleAppend('\nIndexedDB keys:');
      keys.forEach(k=> renderConsoleAppend('  ' + k));
    } else {
      renderConsoleAppend('\nIndexedDB: (no keys found matching current world)');
    }
  }).catch(err=>{
    renderConsoleAppend('\nIndexedDB: error listing keys: ' + (err && err.message ? err.message : String(err)));
  });
}

function renderConsoleAppend(text){
  consoleOutput.textContent = consoleOutput.textContent + text;
}

async function runSaveTest(){
  // Test localStorage write & IDB write
  renderConsoleAppend('\n\nRunning save test...');
  try {
    const testKey = SAVE_PREFIX + '__save_test__';
    const testPayload = { t: Date.now(), note: 'save test' };
    localStorage.setItem(testKey, JSON.stringify(testPayload));
    const read = localStorage.getItem(testKey);
    localStorage.removeItem(testKey);
    if (!read) { renderConsoleAppend('\nERROR: write succeeded but read returned null'); }
    else {
      const parsed = JSON.parse(read);
      if (parsed && parsed.note === 'save test') renderConsoleAppend('\nOK: localStorage write/read succeeded');
      else renderConsoleAppend('\nWARN: localStorage read but content mismatch');
    }
  } catch(e) {
    renderConsoleAppend('\nlocalStorage test failed: ' + (e && e.message ? e.message : String(e)));
  }

  // IDB test
  try {
    const id = '__idb_test__' + Date.now();
    const payload = JSON.stringify({ t: Date.now(), note: 'idb test' });
    await idbPut(id, payload);
    const got = await idbGet(id);
    if (got) {
      renderConsoleAppend('\nOK: IndexedDB write/read succeeded');
    } else {
      renderConsoleAppend('\nWARN: IndexedDB read returned null');
    }
    // cleanup
    try { const db = await openIdb(); const tx = db.transaction('saves','readwrite'); tx.objectStore('saves').delete(id); db.close(); } catch(_) {}
  } catch(e) {
    renderConsoleAppend('\nIndexedDB test failed: ' + (e && e.message ? e.message : String(e)));
  }
}

function listSaveKeys(){
  const out = [];
  out.push('Listing keys matching prefix / index:');
  try {
    for (let i=0;i<localStorage.length;i++){
      const k = localStorage.key(i);
      if (!k) continue;
      if (k.indexOf(SAVE_PREFIX) === 0 || k === WORLDS_KEY || (currentWorldId && k.indexOf(currentWorldId) !== -1)) out.push('  ' + k);
    }
    if (out.length === 1) out.push('  (none found)');
  } catch(e){
    out.push('Failed to list keys: ' + (e && e.message ? e.message : String(e)));
  }
  consoleOutput.textContent = consoleOutput.textContent + '\n\n' + out.join('\n');

  // IDB keys (async)
  idbListKeysContaining(currentWorldId).then(keys=>{
    if (keys && keys.length){
      consoleOutput.textContent = consoleOutput.textContent + '\n\nIndexedDB keys:\n' + keys.join('\n');
    } else {
      consoleOutput.textContent = consoleOutput.textContent + '\n\nIndexedDB: (no keys found matching current world)';
    }
  }).catch(err=>{
    consoleOutput.textContent = consoleOutput.textContent + '\n\nIndexedDB: error listing keys: ' + (err && err.message ? err.message : String(err));
  });
}

function downloadCurrentSave(){
  if (!currentWorldId) { alert('No current world to download'); return; }
  try {
    // 1) direct key in localStorage
    const directKey = SAVE_PREFIX + currentWorldId;
    let raw = localStorage.getItem(directKey);
    if (raw){
      triggerDownload(raw, `ims_save_${currentWorldId}.json`);
      return;
    }
    // 2) lastSaveKey fallback
    if (lastSaveKey && lastSaveKey.indexOf('idb:') !== 0){
      raw = localStorage.getItem(lastSaveKey);
      if (raw){
        triggerDownload(raw, `ims_save_${currentWorldId}.json`);
        return;
      }
    }
    // 3) search any localStorage key containing currentWorldId
    const candidates = [];
    for (let i=0;i<localStorage.length;i++){
      const k = localStorage.key(i);
      if (!k) continue;
      if (k.indexOf(currentWorldId) !== -1) candidates.push(k);
    }
    if (candidates.length === 1){
      raw = localStorage.getItem(candidates[0]);
      if (raw){ triggerDownload(raw, `${candidates[0]}.json`); return; }
    } else if (candidates.length > 1){
      const pref = candidates.find(k => k.indexOf(SAVE_PREFIX) === 0);
      if (pref){ raw = localStorage.getItem(pref); if (raw){ triggerDownload(raw, `${pref}.json`); return; } }
      consoleOutput.textContent = consoleOutput.textContent + '\n\n' + ('Multiple candidate keys found:\n' + candidates.join('\n'));
      alert('Multiple candidate save keys found ‚Äî check the Dev Console (List save keys) to pick one.');
      return;
    }

    // 4) If not present in localStorage, try IndexedDB
    idbGet(currentWorldId).then(rawIdb => {
      if (rawIdb){
        triggerDownload(rawIdb, `ims_save_idb_${currentWorldId}.json`);
      } else {
        // try lastSaveKey if it was idb:
        if (lastSaveKey && lastSaveKey.indexOf('idb:') === 0){
          const id = lastSaveKey.substring(4);
          idbGet(id).then(r => {
            if (r) triggerDownload(r, `ims_save_idb_${id}.json`);
            else {
              alert('No save payload found for current world (checked localStorage and IndexedDB). Open Dev Console ‚Üí List save keys for details.');
              consoleOutput.textContent = consoleOutput.textContent + '\n\nDownload failed: no save key found for ' + currentWorldId;
            }
          }).catch(err=>{
            alert('Error reading from IndexedDB: ' + (err && err.message ? err.message : String(err)));
          });
        } else {
          alert('No save payload found for current world. I checked:\n- ' + directKey + '\n- lastSaveKey: ' + (lastSaveKey || '(none)') + '\n\nOpen the Dev Console and press "List save keys" to inspect stored keys.');
          consoleOutput.textContent = consoleOutput.textContent + '\n\nDownload failed: no save key found for ' + currentWorldId;
        }
      }
    }).catch(err=>{
      alert('Error checking IndexedDB: ' + (err && err.message ? err.message : String(err)));
    });

  } catch(e){
    alert('Download failed: ' + (e && e.message ? e.message : String(e)));
  }
}
function triggerDownload(raw, filename){
  try {
    const blob = new Blob([raw], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  } catch(e){
    alert('Download failed: ' + (e && e.message ? e.message : String(e)));
  }
}

function copyConsoleLog(){
  const text = consoleOutput.textContent || '';
  if (navigator.clipboard && navigator.clipboard.writeText){
    navigator.clipboard.writeText(text).then(()=>{
      consoleOutput.textContent = consoleOutput.textContent + '\n\n[Copied console log to clipboard]';
    }).catch(err=>{
      fallbackCopy(text);
    });
  } else {
    fallbackCopy(text);
  }
}
function fallbackCopy(text){
  try {
    const ta = document.createElement('textarea');
    ta.value = text;
    document.body.appendChild(ta);
    ta.select();
    ta.setSelectionRange(0, ta.value.length);
    const ok = document.execCommand('copy');
    ta.remove();
    if (ok) consoleOutput.textContent = consoleOutput.textContent + '\n\n[Copied console log to clipboard]';
    else consoleOutput.textContent = consoleOutput.textContent + '\n\n[Copy failed: execCommand returned false]';
  } catch(e){
    consoleOutput.textContent = consoleOutput.textContent + '\n\n[Copy failed: ' + (e && e.message ? e.message : String(e)) + ']';
  }
}

/* programmatic toggle for debugging */
window.__showSaveConsole = () => toggleDevConsole(true);

</script>
</body>
</html>
